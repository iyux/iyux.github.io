<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赶路贝壳</title>
  
  <subtitle>想点好活儿整整</subtitle>
  <link href="https://iyux.github.io/atom.xml" rel="self"/>
  
  <link href="https://iyux.github.io/"/>
  <updated>2022-04-28T16:28:28.212Z</updated>
  <id>https://iyux.github.io/</id>
  
  <author>
    <name>yux</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我为什么会紧张啊</title>
    <link href="https://iyux.github.io/2022/04/29/why-am-i-so-nervous/"/>
    <id>https://iyux.github.io/2022/04/29/why-am-i-so-nervous/</id>
    <published>2022-04-28T16:28:28.000Z</published>
    <updated>2022-04-28T16:28:28.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="再记一次面试经历，顺便再总结一下自己"><a href="#再记一次面试经历，顺便再总结一下自己" class="headerlink" title="再记一次面试经历，顺便再总结一下自己"></a>再记一次面试经历，顺便再总结一下自己</h2><blockquote><p>2022/4/28 面试滴滴造车高性能计算岗<br>啊啊啊啊啊!</p></blockquote><span id="more"></span><p>&emsp;&emsp;前半段聊得自我感觉也还行，至少自己的项目经历，自己做过的东西，大家已有的共识，对一些技术点的解决办法，难点之类，都有一些可以探讨的地方。讲这些东西，我是可以和对方交流，我自问也不是一个社恐的人，我感觉我也能保持轻松的状态面对接下来的面试。但是进入到第二个环节:写代码，自己就拉了跨，至少我自己是这样以为。<br>&emsp;&emsp;进入第二给环节，面试官说我们来写一段简单的代码，当打开IDE的时候，我就感觉不对了，血压上来了，是熟悉的断片式紧张，脑子好像就思考不了东西。简简单单一个矩阵转置代码片，如果要我现在看来，简直就是愚蠢，质疑我为什么会犯这样的错误。首先访存的计算，C参数输入肯定不能把 int** in 解析成二维矩阵，计算机本就是线性地址，编译器更是不能解析，应该为 int[x][]，虽然这不是解决算法问题的合理形式，但至少不是一个不专业而又愚蠢的错误。另外，访存操作的index计算也存在问题，我似乎陷入了一种不想思考的直接躺平的状态。<br>&emsp;&emsp;我熟悉这种感觉，从小到大，我干事情的时候，不论是写作文还是做题，我都不喜欢有人在旁边看着我或者说让我感觉他在看着我，这会令我很紧张，就如同现在工位上编辑博客的我，如果旁边的人突然起身，从我背后的过道经过，我都要下意识的切屏，切出我正在编辑的画面，一旦有人在看着我，我脑子立马宕机。奇怪的是，我并不介意把我已经完成的东西给别人分享，就如同分享代码一样，我会说什么地方是我设计的巧思，也乐意与别人探讨，但是别人看着我敲就感觉手足无措。我一直把这种状态当作是紧张，暗示我只要多经历就能锻炼心态，得到缓解，但是这毫无作用。</p><hr><p>&emsp;&emsp;过后求助了万能的知乎，有人说是社恐，有人说是自卑，但我觉得这些都不对，我也感觉自己不是这样的人。突然瞄到有个老哥说，你可能有点完美主义，你觉得你现在正在做的东西给别人展示起来完全达不到你自己的基本要求，害怕错误，会因此感觉到失败，这完全脱离了你的控制。我又知道我语言上的辩解肯定不能当作理由说服人的，因为我自己就是这样去看别人的。我不知道面试官怎么看这种愚蠢的错误，像一个编码新手一样，如果身份互换，我肯定直接走人了把(\捂脸)<br>&emsp;&emsp;确实是这样，我不习惯做给人看，这会让我爆紧张，我更愿意做完再给人看。</p><hr><p>&emsp;&emsp;这看起来能作为一种解释，面试后回看我之前写的代码，这是什么狗*，我为什么会写出这种东西。<br>&emsp;&emsp;毕业以来，我自问我代码写得不差，甚至有些执拗的品味，我一直给朋友说，代码写出来要错落有致，结构清晰，像诗一样。加上我本就是体系结构方向出身，看代码逻辑行为会不自觉的对应到具体的运行时堆栈的行为，对变量赋值和对象赋值就会有些敏感。虽然一些naive的代码会被编译器优化得一样高效，但我就会忍不住在编码的时侯去关注。<br>&emsp;&emsp;我写代码的速度真的很慢，想好了结构才去写，堆上去的代码一点都不美妙，除非我没有心里包袱，就好像去抄作业才不管作业做得好不好(狗头)。<br>&emsp;&emsp;一路以来，从智芯开始，听到的都是说顶顶顶(我还记得当年给测试大姐讲python的时候，她说我讲得比她在外面报的培训班都要清晰)；后面到了重大，前期还没摸清学校套路的我还在认真做项目，听到的也是老师的”小伙可以啊”和实验室老弟的”yyds”。(虽然后期开摆\狗头)。我也知道自己也远达不到大佬的地步，天才大佬实在太强了。我只希望我给出的东西首先一定是要让自己满意。</p><hr><p>&emsp;&emsp;怎么办呢，就是会紧张，别人看我做事的时候就是会大脑宕机，老毛病了。<br>&emsp;&emsp;……想办法吗，还是认了？从小到大都没变过<br>&emsp;&emsp;之前听别人说NVIDIA的方法是给人一道较难的题，让回去自己用CUDA解决，回头面试时给人说你是怎么去设计的，我感觉这是一个思路。</p><p><img src="https://yuximage-1303861842.cos.ap-nanjing.myqcloud.com/2022-h/2022-4-28-1.jpg" alt="bella"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;再记一次面试经历，顺便再总结一下自己&quot;&gt;&lt;a href=&quot;#再记一次面试经历，顺便再总结一下自己&quot; class=&quot;headerlink&quot; title=&quot;再记一次面试经历，顺便再总结一下自己&quot;&gt;&lt;/a&gt;再记一次面试经历，顺便再总结一下自己&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;2022/4/28 面试滴滴造车高性能计算岗&lt;br&gt;啊啊啊啊啊!&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://iyux.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://iyux.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>TVM遍历器设计,functor(仿函数)</title>
    <link href="https://iyux.github.io/2022/04/29/TVM-ExprFunctor-design/"/>
    <id>https://iyux.github.io/2022/04/29/TVM-ExprFunctor-design/</id>
    <published>2022-04-28T16:28:10.000Z</published>
    <updated>2022-04-28T16:28:10.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>功能是提供一个能够对图结构(节点为对象Expr)的数据流图进行深度优先搜索的基础类，并且可以多态注册当处理对象为不同的Expr子类时进行不同的处理。<br>具体的遍历器基础类ExprFunctor实现为:</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExprFunctor</span>&lt;</span><span class="built_in">R</span>(<span class="keyword">const</span> Expr&amp; n, Args...)&gt; &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">using</span> TSelf = ExprFunctor&lt;<span class="built_in">R</span>(<span class="keyword">const</span> Expr&amp; n, Args...)&gt;;</span><br><span class="line">  <span class="keyword">using</span> FType = tvm::NodeFunctor&lt;<span class="built_in">R</span>(<span class="keyword">const</span> ObjectRef&amp; n, TSelf* self, Args...)&gt;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/*! \brief the result type of this functor */</span></span><br><span class="line">  <span class="keyword">using</span> result_type = R;</span><br><span class="line">  <span class="comment">/*! \brief virtual destructor */</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ExprFunctor</span>() &#123;&#125;</span><br><span class="line">  <span class="comment">/*!</span></span><br><span class="line"><span class="comment">   * \brief Same as call.</span></span><br><span class="line"><span class="comment">   * \param n The expression node.</span></span><br><span class="line"><span class="comment">   * \param args Additional arguments.</span></span><br><span class="line"><span class="comment">   * \return The result of the call</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Expr&amp; n, Args... args)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">VisitExpr</span>(n, std::forward&lt;Args&gt;(args)...); &#125;</span><br><span class="line">  <span class="comment">/*!</span></span><br><span class="line"><span class="comment">   * \brief The functor call.</span></span><br><span class="line"><span class="comment">   * \param n The expression node.</span></span><br><span class="line"><span class="comment">   * \param args Additional arguments.</span></span><br><span class="line"><span class="comment">   * \return The result of the call</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr</span><span class="params">(<span class="keyword">const</span> Expr&amp; n, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ICHECK</span>(n.<span class="built_in">defined</span>()) &lt;&lt; <span class="string">&quot;Found null pointer node while traversing AST. The previous pass may &quot;</span></span><br><span class="line">                           <span class="string">&quot;have generated invalid data.&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> FType vtable = <span class="built_in">InitVTable</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vtable</span>(n, <span class="keyword">this</span>, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Functions that can be overriden by subclass</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr_</span><span class="params">(<span class="keyword">const</span> ConstantNode* op, Args... args)</span> EXPR_FUNCTOR_DEFAULT</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr_</span><span class="params">(<span class="keyword">const</span> TupleNode* op, Args... args)</span> EXPR_FUNCTOR_DEFAULT</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr_</span><span class="params">(<span class="keyword">const</span> VarNode* op, Args... args)</span> EXPR_FUNCTOR_DEFAULT</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr_</span><span class="params">(<span class="keyword">const</span> GlobalVarNode* op, Args... args)</span> EXPR_FUNCTOR_DEFAULT</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr_</span><span class="params">(<span class="keyword">const</span> FunctionNode* op, Args... args)</span> EXPR_FUNCTOR_DEFAULT</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr_</span><span class="params">(<span class="keyword">const</span> CallNode* op, Args... args)</span> EXPR_FUNCTOR_DEFAULT</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr_</span><span class="params">(<span class="keyword">const</span> LetNode* op, Args... args)</span> EXPR_FUNCTOR_DEFAULT</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr_</span><span class="params">(<span class="keyword">const</span> IfNode* op, Args... args)</span> EXPR_FUNCTOR_DEFAULT</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr_</span><span class="params">(<span class="keyword">const</span> OpNode* op, Args... args)</span> EXPR_FUNCTOR_DEFAULT</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr_</span><span class="params">(<span class="keyword">const</span> TupleGetItemNode* op, Args... args)</span> EXPR_FUNCTOR_DEFAULT</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr_</span><span class="params">(<span class="keyword">const</span> RefCreateNode* op, Args... args)</span> EXPR_FUNCTOR_DEFAULT</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr_</span><span class="params">(<span class="keyword">const</span> RefReadNode* op, Args... args)</span> EXPR_FUNCTOR_DEFAULT</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr_</span><span class="params">(<span class="keyword">const</span> RefWriteNode* op, Args... args)</span> EXPR_FUNCTOR_DEFAULT</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr_</span><span class="params">(<span class="keyword">const</span> ConstructorNode* op, Args... args)</span> EXPR_FUNCTOR_DEFAULT</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExpr_</span><span class="params">(<span class="keyword">const</span> MatchNode* op, Args... args)</span> EXPR_FUNCTOR_DEFAULT</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> R <span class="title">VisitExprDefault_</span><span class="params">(<span class="keyword">const</span> Object* op, Args...)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Do not have a default for &quot;</span> &lt;&lt; op-&gt;<span class="built_in">GetTypeKey</span>();</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// initialize the vtable.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> FType <span class="title">InitVTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FType vtable;</span><br><span class="line">    <span class="comment">// Set dispatch</span></span><br><span class="line">    <span class="built_in">RELAY_EXPR_FUNCTOR_DISPATCH</span>(ConstantNode);</span><br><span class="line">    <span class="built_in">RELAY_EXPR_FUNCTOR_DISPATCH</span>(TupleNode);</span><br><span class="line">    <span class="built_in">RELAY_EXPR_FUNCTOR_DISPATCH</span>(VarNode);</span><br><span class="line">    <span class="built_in">RELAY_EXPR_FUNCTOR_DISPATCH</span>(GlobalVarNode);</span><br><span class="line">    <span class="built_in">RELAY_EXPR_FUNCTOR_DISPATCH</span>(FunctionNode);</span><br><span class="line">    <span class="built_in">RELAY_EXPR_FUNCTOR_DISPATCH</span>(CallNode);</span><br><span class="line">    <span class="built_in">RELAY_EXPR_FUNCTOR_DISPATCH</span>(LetNode);</span><br><span class="line">    <span class="built_in">RELAY_EXPR_FUNCTOR_DISPATCH</span>(IfNode);</span><br><span class="line">    <span class="built_in">RELAY_EXPR_FUNCTOR_DISPATCH</span>(OpNode);</span><br><span class="line">    <span class="built_in">RELAY_EXPR_FUNCTOR_DISPATCH</span>(TupleGetItemNode);</span><br><span class="line">    <span class="built_in">RELAY_EXPR_FUNCTOR_DISPATCH</span>(RefCreateNode);</span><br><span class="line">    <span class="built_in">RELAY_EXPR_FUNCTOR_DISPATCH</span>(RefReadNode);</span><br><span class="line">    <span class="built_in">RELAY_EXPR_FUNCTOR_DISPATCH</span>(RefWriteNode);</span><br><span class="line">    <span class="built_in">RELAY_EXPR_FUNCTOR_DISPATCH</span>(ConstructorNode);</span><br><span class="line">    <span class="built_in">RELAY_EXPR_FUNCTOR_DISPATCH</span>(MatchNode);</span><br><span class="line">    <span class="keyword">return</span> vtable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>遍历器的基类，多态对节点进行访问。具体到每个子类的实现，如常量折叠pass的图深度优先遍历器，重载各个节点遍历函数，添加对具体node的的修改操作。<br>内部通过访问类的静态变量 vtable 进行，vtable是一个仿函数，定义为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RELAY_EXPR_FUNCTOR_DISPATCH(OP)                                                    \</span></span><br><span class="line"><span class="meta">  vtable.template set_dispatch<span class="meta-string">&lt;OP&gt;</span>([](const ObjectRef&amp; n, TSelf* self, Args... args) &#123;     \</span></span><br><span class="line"><span class="meta">    return self-&gt;VisitExpr_(static_cast<span class="meta-string">&lt;const OP*&gt;</span>(n.get()), std::forward<span class="meta-string">&lt;Args&gt;</span>(args)...); \</span></span><br><span class="line"><span class="meta">  &#125;);</span></span><br></pre></td></tr></table></figure><blockquote><p>vtable.template 的语法表示 vtable模板类 中的模板函数，具体解析见<a href="https://blog.csdn.net/kh815/article/details/115680799">调用模板类的模板函数前必须加template关键字的情况</a>,参考《C++ Template》一书中的9.3.2和9.3.3两节</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeFunctor</span>&lt;</span><span class="built_in">R</span>(<span class="keyword">const</span> ObjectRef&amp; n, Args...)&gt; &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/*! \brief internal function pointer type */</span></span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">R</span> <span class="params">(*FPointer)</span><span class="params">(<span class="keyword">const</span> ObjectRef&amp; n, Args...)</span></span>;</span><br><span class="line">  <span class="comment">/*! \brief refer to itself. */</span></span><br><span class="line">  <span class="keyword">using</span> TSelf = NodeFunctor&lt;<span class="built_in">R</span>(<span class="keyword">const</span> ObjectRef&amp; n, Args...)&gt;;</span><br><span class="line">  <span class="comment">/*! \brief internal function table */</span></span><br><span class="line">  std::vector&lt;FPointer&gt; func_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/*! \brief the result type of this functor */</span></span><br><span class="line">  <span class="keyword">using</span> result_type = R;</span><br><span class="line">  <span class="comment">/*!</span></span><br><span class="line"><span class="comment">   * \brief Whether the functor can dispatch the corresponding Node</span></span><br><span class="line"><span class="comment">   * \param n The node to be dispatched</span></span><br><span class="line"><span class="comment">   * \return Whether dispatching function is registered for n&#x27;s type.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">can_dispatch</span><span class="params">(<span class="keyword">const</span> ObjectRef&amp; n)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> type_index = n-&gt;<span class="built_in">type_index</span>();</span><br><span class="line">    <span class="keyword">return</span> type_index &lt; func_.<span class="built_in">size</span>() &amp;&amp; func_[type_index] != <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*!</span></span><br><span class="line"><span class="comment">   * \brief invoke the functor, dispatch on type of n</span></span><br><span class="line"><span class="comment">   * \param n The Node argument</span></span><br><span class="line"><span class="comment">   * \param args The additional arguments</span></span><br><span class="line"><span class="comment">   * \return The result.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> ObjectRef&amp; n, Args... args)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ICHECK</span>(<span class="built_in">can_dispatch</span>(n)) &lt;&lt; <span class="string">&quot;NodeFunctor calls un-registered function on type &quot;</span></span><br><span class="line">                            &lt;&lt; n-&gt;<span class="built_in">GetTypeKey</span>();</span><br><span class="line">    <span class="keyword">return</span> (*func_[n-&gt;<span class="built_in">type_index</span>()])(n, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*!</span></span><br><span class="line"><span class="comment">   * \brief set the dispacher for type TNode</span></span><br><span class="line"><span class="comment">   * \param f The function to be set.</span></span><br><span class="line"><span class="comment">   * \tparam TNode the type of Node to be dispatched.</span></span><br><span class="line"><span class="comment">   * \return reference to self.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TNode&gt;</span><br><span class="line">  <span class="function">TSelf&amp; <span class="title">set_dispatch</span><span class="params">(FPointer f)</span> </span>&#123;  <span class="comment">// NOLINT(*)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tindex = TNode::<span class="built_in">RuntimeTypeIndex</span>();</span><br><span class="line">    <span class="keyword">if</span> (func_.<span class="built_in">size</span>() &lt;= tindex) &#123;</span><br><span class="line">      func_.<span class="built_in">resize</span>(tindex + <span class="number">1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ICHECK</span>(func_[tindex] == <span class="literal">nullptr</span>) &lt;&lt; <span class="string">&quot;Dispatch for &quot;</span> &lt;&lt; TNode::_type_key &lt;&lt; <span class="string">&quot; is already set&quot;</span>;</span><br><span class="line">    func_[tindex] = f;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>NodeFunctor是一个对于节点node的仿函数类，输入为<code>const ObjectRef&amp; n, Args...</code> 返回值是 R，这个类有多态的属性，可注册函数。通过不同的ObjectRef参数从而多态调用注册好的函数</p><p>在ExprFunctor私有变量里，宏将对应的静态成员进行初始化，绑定到对应的节点方法之中，绑定的方法是ExprFunctor 的 VisitExper_方法，当外部调用该对象时，调用的路径为</p><p>R VisitExpr()<br>获得类的静态 vtable 次部分的函数已经被宏定义时，进行静态初始化，函数已经注册到NodeFunctor::func_中了</p><p>NodeFunctor(objref&amp;, arg…)<br>调用子类objref对应的位于，func_中的函数。</p><blockquote><p>此部分看起来令人疑惑，在遍历器的构造上又多套了一层 <code>static FType vtable = InitVTable()</code>， 其实光通过VisitExpr的多态调用就已经能完成深搜功能了，vtable的设计看起来多余，其实不然，在文章最后给出我的理解</p></blockquote><p>遍历器的基类已经通过多态分发搭出了基本的框架。<br>下面的几种遍历子类的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ExprVisitor&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">const</span> Object*, <span class="keyword">size_t</span>&gt; visit_counter_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExprMutator&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::unordered_map&lt;Expr, Expr, ObjectPtrHash, ObjectPtrEqual&gt; memo_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * \brief A wrapper around ExprVisitor which traverses the Dataflow Normal AST.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MixedModeVisitor treats Expr as dataflow graph, and visits in post-DFS order</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MixedModeVisitor provides the same recursive API as ExprVisitor, and uses</span></span><br><span class="line"><span class="comment"> * recursion to traverse most forms of the IR, but under the hood it expands nested dataflow regions</span></span><br><span class="line"><span class="comment"> * of the graph and processes them iteratively to prevent stack overflows</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixedModeVisitor</span> :</span> <span class="keyword">public</span> ::tvm::relay::ExprVisitor&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixedModeMutator</span> :</span> <span class="keyword">public</span> ::tvm::relay::ExprMutator&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>FunctorNode<br>的作用在于，在自己定义的类里，如果想要对ObjectRef进行操作，并且这种操作的多态的，可以注册函数，且易于扩展。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> \\brief Useful macro to set NodeFunctor dispatch in a global <span class="keyword">static</span> field.</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use NodeFunctor to implement ReprPrinter similar to Visitor Pattern.</span></span><br><span class="line"><span class="comment">// vtable allows easy patch of new Node types, without changing</span></span><br><span class="line"><span class="comment">// interface of ReprPrinter.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReprPrinter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::ostream&amp; stream;</span><br><span class="line">the dispatch function.</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Expr e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> FType&amp; f = *<span class="built_in">vtable</span>();</span><br><span class="line">     <span class="built_in">f</span>(e, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">using</span> FType = NodeFunctor&lt;<span class="built_in"><span class="keyword">void</span></span> (<span class="keyword">const</span> ObjectRef&amp;, ReprPrinter* )&gt;;</span><br><span class="line">  <span class="comment">// function to return global function table</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> FType&amp; <span class="title">vtable</span><span class="params">()</span></span>;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">// in cpp/cc file</span></span><br><span class="line">  <span class="function">ReprPrinter::FType&amp; <span class="title">ReprPrinter::vtable</span><span class="params">()</span> </span>&#123; <span class="comment">// NOLINT(*)</span></span><br><span class="line">   <span class="keyword">static</span> FType inst; <span class="keyword">return</span> inst;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TVM_STATIC_IR_FUNCTOR</span>(ReprPrinter, vtable)</span><br><span class="line"> .set_dispatch&lt;Add&gt;([](<span class="keyword">const</span> ObjectRef&amp; ref, ReprPrinter* p) &#123;</span><br><span class="line">   <span class="keyword">auto</span>* n = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> Add*&gt;(ref.<span class="built_in">get</span>());</span><br><span class="line">   p-&gt;<span class="built_in">print</span>(n-&gt;a);</span><br><span class="line">   p-&gt;stream &lt;&lt; <span class="string">&#x27;+&#x27;</span></span><br><span class="line">    p-&gt;<span class="built_in">print</span>(n-&gt;b);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述打打印类有两种实现方式</p><ol><li>写很多的 print(Expr e) 的多态实现， 如print(Add e) 等</li><li>采用静态 vtable的,对函数进行注册面向add,min等，在外部的打印类只有print(Expr e)一个入口，前提的继承是 ObjectRef &lt;- Expr &lt;- Add等， 并且次注册可以在任意cpp里完成，因为ReprPrinter::vtable()是静态的</li></ol><p>在类ReprPrinter中包含<br><code>using FType = NodeFunctor&lt;void (const ObjectRef&amp;, ReprPrinter* )&gt;;</code><br>这表明 vtable里注册的函数形式的输入参数为 <code>const ObjectRef&amp;, ReprPrinter*</code> 返回值void，通过 ObjectRef进行多态</p><p><code>static FType&amp; vtable();</code>返回静态vtable的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReprPrinter::FType&amp; <span class="title">ReprPrinter::vtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> FType inst;</span><br><span class="line">  <span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TVM_STATIC_IR_FUNCTOR(ReprPrinter, vtable).set_dispatch&lt;Add&gt; ...</code> 展开为</p><p><code>static TVM_ATTRIBUTE_UNUSED auto&amp; __make_functor_ReprPrinter__count__ ReprPrinter::vtable().set_dispatch&lt;Add&gt; ...</code></p><p>__COUNTER__为编译宏，展开为次数<br>含义是定义一个静态变量<code>__make_functor_ReprPrinter__count__</code>，并使用 <code>ReprPrinter::vtable().set_dispatch&lt;Add&gt; ...</code> 进行初始化，在初始化里，将函数注册进去</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>1.ObjetctRef里有type_type的定义这表明了不同子类的type_index_是不同的，这个特性给自己的vtabke提供了索引</p><p>2.静态变量的初始化是在程序开始之前，一般存储在.bss或者.data段上，并且静态变量的初始化可以调用函数<code>static int aa = func1()</code>是合法的</p><hr><p>注意:<br>此部分的返回需要通过静态函数的形式，如果采用静态变量会产生错误</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReprPrinter&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> FType vtable;  <span class="comment">//编译能过，产生链接错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等效实现"><a href="#等效实现" class="headerlink" title="等效实现"></a>等效实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="function">CC&amp; <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> in)</span></span>&#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(in);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> kk;</span><br><span class="line">    CC v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> BB&amp; <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> BB b;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> BB bin;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span>&amp; ll = AA::<span class="built_in">get</span>().v.<span class="built_in">push_back</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span>&amp; ll2 = AA::bin.v.<span class="built_in">push_back</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; ll.v.<span class="built_in">size</span>()  &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt; ll2.v.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">//编译错误</span></span><br><span class="line">    <span class="comment">//test.cpp:(.text+0xe4): undefined reference to `AA::bin&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接错误的具体成应有待研究</p><h3 id="值得学习的地方"><a href="#值得学习的地方" class="headerlink" title="值得学习的地方"></a>值得学习的地方</h3><p>1.静态变量的初始化条件与初始化阶段<br>2.通过静态变量与子类的类别标记实现多态调用vtable，类似c++虚函数的vtable，是一种查询手段<br>3.多分发</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h2&gt;&lt;p&gt;功能是提供一个能够对图结构(节点为对象Expr)的数据流图进行深度优先搜索的基础类，并且可以多态注册当处理对象为不同的Expr子类时进行不同的处理。&lt;br&gt;具体的遍历器基础类ExprFunctor实现为:&lt;/p&gt;</summary>
    
    
    
    <category term="代码阅读" scheme="https://iyux.github.io/categories/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="TVM" scheme="https://iyux.github.io/categories/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/TVM/"/>
    
    
    <category term="TVM" scheme="https://iyux.github.io/tags/TVM/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云做图床</title>
    <link href="https://iyux.github.io/2021/12/23/tencent-tuchuang/"/>
    <id>https://iyux.github.io/2021/12/23/tencent-tuchuang/</id>
    <published>2021-12-23T05:28:41.000Z</published>
    <updated>2021-12-23T05:28:41.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><blockquote><p>我略微接触过摄影，需要在blog上分享一点照片，记录一些生活，图片存在本地通过MD来引用不太合适，一方面图片都挺大的，另一方面我也想把这些照片好好分类归档。<br>看了几篇知乎，网络上免费图床，会担心这些机构的生存周期，加上很多都是自己拍的照片，还是换一种方案。</p></blockquote><ul><li>自建服务器存储<br>需要用到云服务器或者vps，自己维护起来也比较费劲，加上开销也挺大的</li><li>云服务器商提供的对象存储</li></ul><span id="more"></span><hr><p>一开始选择用七牛云，每个月有10g的免费空间，扩展也不是很贵。<br>存在的问题：<br>七牛云是通过CDN加速的方式，那么需要一个域名(可以解析二级域名image.yuxwayward.top)来进行绑定。但是在配置过程中了解到域名需要进行备案<br>，我top域名在腾讯云上购买的，一番周折，得到的结果是域名要和ip一起绑定在工信部进行备案，虽然有一些“方法”可以简化，但是终究还是太麻烦</p><hr><p>腾讯云COS的选择：<br>腾讯云上只要认证过的用户，便可以购买COS的服务，且对象是通过腾讯相关的url进行访问，这就免去了备案的烦恼</p><p>腾讯云上的COS礼包，1元一年，50g/月，有get和post的次数限制，对于我来说完全够用了，我也不指望有几个人能看，自己写写东西就好了</p><p>购买之后，在腾讯云的COS页面先，上传文件，复制地址，再md上写图片引用<br>测试如下：<br><img src="https://yuximage-1303861842.cos.ap-nanjing.myqcloud.com/2021-4/0417-1.jpg" alt="iamge"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>腾讯COS有防盗链的设置，我大概整个白名单就行了吧-.-</li><li>PicGo可以对腾讯COS进行管理，批量操作什么的，这部分再进行学习</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我略微接触过摄影，需要在blog上分享一点照片，记录一些生活，图片存在本地通过MD来引用不太合适，一方面图片都挺大的，另一方面我也想把这些照片好好分类归档。&lt;br&gt;看了几篇知乎，网络上免费图床，会担心这些机构的生存周期，加上很多都是自己拍的照片，还是换一种方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;自建服务器存储&lt;br&gt;需要用到云服务器或者vps，自己维护起来也比较费劲，加上开销也挺大的&lt;/li&gt;
&lt;li&gt;云服务器商提供的对象存储&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="搬砖之路" scheme="https://iyux.github.io/categories/%E6%90%AC%E7%A0%96%E4%B9%8B%E8%B7%AF/"/>
    
    <category term="hexo" scheme="https://iyux.github.io/categories/%E6%90%AC%E7%A0%96%E4%B9%8B%E8%B7%AF/hexo/"/>
    
    
    <category term="hexo" scheme="https://iyux.github.io/tags/hexo/"/>
    
    <category term="环境搭建" scheme="https://iyux.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>1223想起来了博客</title>
    <link href="https://iyux.github.io/2021/12/23/sorry1223/"/>
    <id>https://iyux.github.io/2021/12/23/sorry1223/</id>
    <published>2021-12-23T05:00:00.000Z</published>
    <updated>2021-12-23T05:42:10.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sorry-我忘了写日记"><a href="#Sorry-我忘了写日记" class="headerlink" title="Sorry, 我忘了写日记"></a>Sorry, 我忘了写日记</h1><blockquote><p>还有2两天就要开考了，肖四还没有背完，怎么办，我枯了，呜呜呜。<br>正在北航当苦逼小牛马，专业吞饼，专注擦屁股20年</p></blockquote><hr><p><strong>9月以来干了什么</strong></p><ul><li>煞笔阿拉善无人机，两箱红牛一周半</li><li>蠢狗二院，docker，k8s截个图，艹</li><li>智障207，摆大烂，倒霉蛋竟是我自己</li><li>期末不当人</li></ul><p><strong>开了坑没去填</strong></p><ul><li>/proc 下文件分析</li><li>TVM代码学习(断断续续，看完p+c混编，就被叫去当牛马)</li><li>std代码学习</li></ul><p><strong>收获了什么</strong></p><ul><li>张博煜学习小组的一群沙雕</li></ul><hr><p>上点老图(相机已经吃灰快半年了)<br><img src="https://yuximage-1303861842.cos.ap-nanjing.myqcloud.com/2021-12/122311.jpg" alt="im1"></p><span id="more"></span><p><img src="https://yuximage-1303861842.cos.ap-nanjing.myqcloud.com/2021-12/122312.jpg" alt="im2"><br><img src="https://yuximage-1303861842.cos.ap-nanjing.myqcloud.com/2021-12/122313.jpg" alt="im3"><br><img src="https://yuximage-1303861842.cos.ap-nanjing.myqcloud.com/2021-12/122314.jpg" alt="im4"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Sorry-我忘了写日记&quot;&gt;&lt;a href=&quot;#Sorry-我忘了写日记&quot; class=&quot;headerlink&quot; title=&quot;Sorry, 我忘了写日记&quot;&gt;&lt;/a&gt;Sorry, 我忘了写日记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;还有2两天就要开考了，肖四还没有背完，怎么办，我枯了，呜呜呜。&lt;br&gt;正在北航当苦逼小牛马，专业吞饼，专注擦屁股20年&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;9月以来干了什么&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;煞笔阿拉善无人机，两箱红牛一周半&lt;/li&gt;
&lt;li&gt;蠢狗二院，docker，k8s截个图，艹&lt;/li&gt;
&lt;li&gt;智障207，摆大烂，倒霉蛋竟是我自己&lt;/li&gt;
&lt;li&gt;期末不当人&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开了坑没去填&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/proc 下文件分析&lt;/li&gt;
&lt;li&gt;TVM代码学习(断断续续，看完p+c混编，就被叫去当牛马)&lt;/li&gt;
&lt;li&gt;std代码学习&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;收获了什么&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;张博煜学习小组的一群沙雕&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;上点老图(相机已经吃灰快半年了)&lt;br&gt;&lt;img src=&quot;https://yuximage-1303861842.cos.ap-nanjing.myqcloud.com/2021-12/122311.jpg&quot; alt=&quot;im1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://iyux.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://iyux.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>掌控自己的代码</title>
    <link href="https://iyux.github.io/2021/03/20/%E6%8E%8C%E6%8E%A7%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <id>https://iyux.github.io/2021/03/20/%E6%8E%8C%E6%8E%A7%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81/</id>
    <published>2021-03-20T12:51:30.000Z</published>
    <updated>2021-12-23T05:37:14.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="掌控自己的代码"><a href="#掌控自己的代码" class="headerlink" title="掌控自己的代码"></a>掌控自己的代码</h1><blockquote><p>记一次有收获的面试过程，这可能会改变我迄今为止的代码习惯和认知，并且我会受益于其中<br>休要花里胡哨!!!</p></blockquote><span id="more"></span><p>面试官让我写了一段代码，大致是两个数组之间的相互加减操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> max = <span class="built_in">fmax</span>(arr);</span><br><span class="line"><span class="keyword">float</span> min = <span class="built_in">fmin</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> k = max-min;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr = res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> *i = arr; i &lt; arr + n; i++)&#123;</span><br><span class="line">    *ptr++ = (*i - min)/k * <span class="number">255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面试官:你觉得你的代码有什么问题吗？<br>我: 可能就是在k可能带来的除0问题把<br>面试官:其它的呢？<br>我: …</p><p>面试官: 你写代码一定要肯定自己的输入输出，程序计算出的结构你要肯定，而不是让其他因素来影响你<br>我: …</p><p> <em>你的i是float，prt是uchar，你知道会怎样做类型转换吗</em></p><p> 编译器会自动去做</p><p> <em>一定会这样去做吗，或者有不同的处理办法，不同的编译器呢？不要让编译器去决定你程序的运行结果，要对自己代码的结果要有一个肯定</em></p><p>我明白了，我可以在计算是加上类型转换的关键字</p><hr><p>在我的认知中，代码高手就是各种技巧乱飞，能隐式绝不显示，arr[i]要写成 *(arr + i)，注意布局的美感，一通花里胡哨。而往往忽略了程序的关键问题，正确性和肯定性和易读性</p><p>这是一个小小的问题，但却启发了我。<br>未来，做一个确信自己代码的人</p><p>改变ing</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;掌控自己的代码&quot;&gt;&lt;a href=&quot;#掌控自己的代码&quot; class=&quot;headerlink&quot; title=&quot;掌控自己的代码&quot;&gt;&lt;/a&gt;掌控自己的代码&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;记一次有收获的面试过程，这可能会改变我迄今为止的代码习惯和认知，并且我会受益于其中&lt;br&gt;休要花里胡哨!!!&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="未分类" scheme="https://iyux.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="随笔" scheme="https://iyux.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>blog 计划第一步: hexo + github page 搭建</title>
    <link href="https://iyux.github.io/2021/03/20/blog-%E8%AE%A1%E5%88%92%E7%AC%AC%E4%B8%80%E6%AD%A5-hexo-github-page-%E6%90%AD%E5%BB%BA/"/>
    <id>https://iyux.github.io/2021/03/20/blog-%E8%AE%A1%E5%88%92%E7%AC%AC%E4%B8%80%E6%AD%A5-hexo-github-page-%E6%90%AD%E5%BB%BA/</id>
    <published>2021-03-20T11:36:28.000Z</published>
    <updated>2021-12-23T05:04:19.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人博客之路"><a href="#个人博客之路" class="headerlink" title="个人博客之路"></a>个人博客之路</h1><p>26岁了才开始写博客，不算早，也应该来得及</p><blockquote><p>平时有记笔记的习惯，但是都零零散散，回想起来了就去翻一翻，和别人交流起来最多话是 “这这这，我好像有接触过，我有点印象”，终究没有形成积累。时光匆匆，我竟没有找到过去的影子。</p></blockquote><h2 id="方案及平台"><a href="#方案及平台" class="headerlink" title="方案及平台"></a>方案及平台</h2><p>github page<br>hexo<br>hexo主题: hexo-theme-next<br>nodejs: 12.18.3<br>npm: 6.14.6<br>安装包地址:<a href="https://npm.taobao.org/dist">https://npm.taobao.org/dist</a><br><u>不建议通过apt-get 进行安装，版本太低，hexo有nodejs的版本要求</u><br>## github准备<br>在个人账号下新建仓库名为 <user-name>.github.io<br>## hexo安装<br>下载安装包，并解压到/opt，把路径下的，node，npm执行文件软链到/local/bin下<br>全局安装hexo <br><code>npm install -g hexo</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">//本地运行</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>打开localhost:4000查看效果<br>目录结构:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line"> |   ├── _drafts</span><br><span class="line"> |   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>_config.yml文件用于存放网站的配置信息，你可以在此配置大部分的参数；<br>scaffolds是存放模板的文件夹，当新建文章时，Hexo会根据scaffold来建立文件；<br>source是资源文件夹，用于存放用户资源<br>themes是主题文件夹，存放博客主题，Hexo 会根据主题来生成静态页面。<br>### 通过 hexo-deployer-git 部署<br><u>(略)完成了主机的git配置，name/mail/ssh key 等等</u><br>编辑 _congif.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;你的仓库地址&gt; # https://github.com/xxxx/xxxx.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><code> npm install hexo-deployer-git --save</code><br><code>hexo deploy</code><br>## 安装next主题<br>在blog根目录下 <br><code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code><br>修改_config.yml<br><code>theme: next</code><br>其他 <br>美化方案 <a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a></p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>略</p><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><ul><li>css无法加载（出现蓝底白字）<br>此处由于_config.yml里的url 或 url+root设置问题，导致不能找到资源 <br>修改为<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url:  https://xxx.github.io</span><br><span class="line">root: /xxx.github.io</span><br></pre></td></tr></table></figure></li></ul><h2 id="hexo的使用"><a href="#hexo的使用" class="headerlink" title="hexo的使用"></a>hexo的使用</h2><p>未完待续</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;个人博客之路&quot;&gt;&lt;a href=&quot;#个人博客之路&quot; class=&quot;headerlink&quot; title=&quot;个人博客之路&quot;&gt;&lt;/a&gt;个人博客之路&lt;/h1&gt;&lt;p&gt;26岁了才开始写博客，不算早，也应该来得及&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;平时有记笔记的习惯，但是</summary>
      
    
    
    
    <category term="搬砖之路" scheme="https://iyux.github.io/categories/%E6%90%AC%E7%A0%96%E4%B9%8B%E8%B7%AF/"/>
    
    <category term="hexo" scheme="https://iyux.github.io/categories/%E6%90%AC%E7%A0%96%E4%B9%8B%E8%B7%AF/hexo/"/>
    
    
    <category term="hexo" scheme="https://iyux.github.io/tags/hexo/"/>
    
    <category term="环境搭建" scheme="https://iyux.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
</feed>
